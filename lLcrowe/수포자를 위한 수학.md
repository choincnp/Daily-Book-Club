
# 수학공부 보완

## 목적  

국비지원 학원 6개월을 다니기로 했다.  
합리적인 이유로는 
1. 자소서 및 자료정리, 포폴제작, C#외의 언어공부등 시간을 벌기 위한 의도
2. 취업트랜드에 맞게 공부
3. 모르는게 있을것에 대한 보완.
4. 회사에 맞게 사람을 변환
5. 체력기르기
6. 사회적인 긴장감을 유지할 환경을 조성

비합리적인 이유로는
1. 학원딱지
2. 게임외에 유니티사용 기업을 갈 확률이 높아진다.
3. 이 실력에 학원갈 이유가 있나?
4. 취업시장이 어덯게 될지 모른다. 3월을 보는중

4년동안 1인개발하다가 좀더 많은 노하우와 커리어가 필요하여 취업을 하기로 결정.
취업을 위한 의도로 최근 취업트랜드에 맞게 공부를 하려함

## 요구사항 & 조사

코드는 잘짜지만 아직도 수학이 약하다. 수학의 전체를 볼필요는 없고
필요한 부분만 가져가기 위한 수학공부

유니티관련 사람이어야됨.
자세히 공부하자

확인해보니 이쪽이 괜찮게 강의해주는거 같아 이걸로 선택했다.
또한 책하나 이득우의 게임수학 책을 볼 예정이다.

수포자를 위한 게임 수학
https://www.youtube.com/playlist?list=PL-xqYJ8bjgMC-p94R7iXjFCs-znRg93PJ


---


#### 20230209

### 1) OT
유니티떄문에 사람들이 공부를 안한다.

게임개발자라면 수학을 잘 숙지하고 있어야하는데
학생 및 뉴키들이 수학공부를 안한다.

수학적 배경이 부족해도 유니티는 충분히 할수 있게 만들어서
공부를 '별로' 안한다.  

유니티를 사용하더라도 수학공부는 꾸준히 해야된다  
유니티는 게임개발의 민주화를 위한 목표 아래로
누구나 게임개발을 할수 있도록 만든 엔진뿐이지.  
그렇다고 수학공부를 안해야 할정도로 작동방식은 아님.

기초부분의 커리큘럼을 만듬에도 불구하고
학생들이 별로 안할려구함. 왜냐하면 어려우니까. 그렇다고 강제로 주입할수는 없죠


게임개발도 마찬가지 파이프라인, 수학적인기반, 하드웨어구조 같은 각가지 많은 기초지식
들을 알고 있어야 게임개발을 더 깊이 있게 더 최적화된 게임을 개발할수 있다.

여기서 말하는 개발자는 게임개발자만이 아닌 게임개발을 하는 모든분들은
수학을 알고 있어야된다.

게임에 필요한 수학적인 내용들을 다룰것이다.

### 2) 피타고라스의 정리 정확한 이해

#### 20230210

//목적 : A좌표에서 B좌표의 길이를 구하기, 40/sec
20, 20 -> 100, 80 

길이를 알아야 최종걸리는 시간을 알수 있음.

수학을 할때 짜증나는건.  
용어들이 와닿지않기떄문이다.  
더짜증나는건 이것들을 영어로 알고 있어야된다.  
자료를 찾아보면 다 영어로 되있음.  

빗변 = hypotenuse = c
제곱 = (ㅊ + 특수문자) => ²  
루트(제곱근) = (ㄷ + 특수문자) => ^, √  

1. c² = a² + b²
2. c²^2 = (a² + b²)^2 (양쪽에 루트를 씌우면)
3. c = (a² + b²)^2 (가 되니 (a² + b²)^2 여기를 구하면 나옴)

고로 공식은
x좌표, y좌표끼리 빼버리는데 목적(타겟)이 주가 됨
고로 목적은 좌표값 (100, 80) 이니까
순서는
1. ((100 - 20)² + (80 - 20)²) ^2
2. ((80)² + (60)²) ^2
3. (6400 + 3600) ^2
4. (10000) ^2
5. 100

고로 길이C 값은 == 100 이다
그 다음에 100길이에서 초당 40만큼 움직이니까
time = 100 / 40 = 2.5초



---

![피타고라스증명방법](피타고라스증명방법.png)

---

### 3) 선형대수학(Linear Algebra)

선형대수학을 꺼내면 많이 무서워 반응을 낸다.

사실 별거 아닌거다.
수학에서는 사전적인 정의만 말하니 확 안닿아옴.

선형대수학
선형 대수 학 두단어로 나눌 수 있다.

선형적인 공간에서 대수를 다루는 학문이다
※ 선형적이란 것은 어떤 성질이 변하는데 그 변수가 1차원적이다.
 즉 어떤 신호에 기울기만 곱한 형태와 같다는 것.
이는 직선처럼 똑바른 도형, 또는 그와 비슷한 성질을 갖는 대상을 뜻한다.

대수
미지수등과 같이 "무언가를 대신하는 수" 라서 대수 이다.

미지수를 가지고 지지고 볶고 하는걸 대수라고 한다.

프로그래밍을 하게 되면은 대수학을 쓸수 밖에 없는것이다.
우린 대수학을 계속 쓰고 있었던것이다.

선형 이라는것은 선의 형태이다

블랙홀이라든가 오그라지는 형태는 선의 형태가 아니다

3차원 2차원공간은 흔히말하는 선형 공간이다.

※ 유클리드 공간
![유클리드공간](유클리드공간.png)

서로 직교해서 쭉 뻣어나가는공간이 유클리드 공간이다.

결국엔 유클리드공간이든 선형공간이든 우리는 계속 이공간을 쓰고 있다
우리는 알게 모르게 쓰고 있다.

선형공간을 다루면서 Vector, Matrix4x4, Quaternion



### 4) 벡터(Vector) 벡터맨은 핵아재!

(오는데는 순서가 있어도 가는데는 순서가 없다)


벡터는 화살표로 생각하면된다
화살표는 크기, 방향을 가지고 있다.
어떤곳에는 속도로 나타낼수 있고 위치로 나타낼수 있다.

벡터의 구성요소
1. 방향
2. 크기

원점에서 특정 지점


x, y가 있는 2차원벡터로 설명.


유니티에서 Transform의 position쪽

벡터는 일반숫자와 마찬가지로 덧셈연산을 가지고 있다

※ 벡터는 위에 화살표를 표현해서 이게 벡터다 라는 뜻을 가지고 있음
벡터를 나타내는 표시가 '화살표'.
덧셈 = a→ + b→ = (a.x + b.x, a.y + b.y)

평행 사변형의 중간부분의 길이가 벡터

![벡터덧셈](벡터덧셈.png)


뺄셈 = a→ - b→ = (a.x - b.x, a.y - b.y)

B벡터에서 A벡터로 향하는 모습이 되고
벡터는 시작점 끝점 개념이 아니라 크기와 방향만 가지고 있어서
원점기준에서 봣을때 좌측에 있는 벡터로 표현됨.

3 - 2 =  3 + (-2)
a→ - b→ = a→ + (-b→)
이렇게 생각하면 됨.


![벡터뺄셈](벡터뺄셈.png)

곱셈, 나눗셈

벡터에는 나눗셈이라는 개념이 없고
곱셈이라는 개념이 있는데 내적, 외적으로 두가지로 설명됨.

이번 시간에는 안다룸


-=벡터의 다른 성질
1. Length(magnitude)
(a² + b²)^2 = Length

벡터의 길이를 나타내는 기호(양옆에 짝대기를 두개씩 친다)
가끔 한개쳐도 통용은 된다. 벡터에 절대값이라는 개념이 없어서
![백터의마크](백터의마크.png)

2. Normalize(단위화)
Length를 1로 만드는 과정을 노말라이징
벡터의 순수한 방향만을 나타내고 싶을때

단위만드는 방법은 
4/4 = 1 되는 방식으로,
벡터를 길이로 나누어버리면 길이가 1인 벡터가 나온다

 = (x / 벡터의 길이, y / 벡터의 길이)

![노말라이즈공식](노말라이즈공식.png)

※정리
vector2 a,b;
a = b + c;
a = b - c;
a.normalize();//단위화, 순수한 방향만을 구해주는
a.magnitude();//길이를 구해주는

원리를 알고 쓰는거와 모른채로 갔다 쓰는거에는 많은 차이가 있음.

수포자의 생각하는 기준이 사람마다 달라서
오지현님의 기준은 엄청낮게 잡을것이므로 밑단부터 할 예정


### 5) 원주율 π(Pi)! 3.14 이 숫자는 도대체 무슨 의미?!

#### 20230211

벡터를 애기하다보면 내적연산을 애기할수밖에 없고
내적을 애기하다보면 삼각함수를 이야기해되고
삼각함수를 애기해야되고 삼각함수를 이야기하면
라디안을 애기해야되고 라디안을 이야기하면
파이를 알고 있어야되고, 이런식으로 엮이고
엮이고 엮여 있기때문에 파이에 대해 알아서
벡터까지 알수 있다.

매우 밑바닥부터 차근차근 애기할려고 함


파이(PI) = 3.14

#### 20230213
파이는 원주율


원주율
원의 원주에 원주율
무슨말이냐하면


원의크기를 확인할려면 

원의 지름이 있고 원주는 원의 둘레를 말하는거고
원주율은 이 원의 지름에 비례해서 원의둘레가 몇이냐
이런걸 원주율이라고 한다
원주 == 원의 둘레

바퀴가 있으면 이바퀴의 지름이 1이면
바퀴가 옆으로 쭉돌아서 한바퀴돌면
원의 둘레가 표시되는데
원의 지름이 1일때 원의 둘레의 길이는 3.14f 


원의 지름이 1이고 내적하는 육각형을 만들었을때


![원을내적하는육각형을만들었을때](원을내적하는육각형을만들었을때.png)

각 길이가 0.5가 된다. 반지름은 0.5이기 때문에  
그 정삼각형들의 각 선분의 길이는 0.5  
육각형일때 길이는 3  


십이각형은

![십이각형](십이각형.png)

직각삼각형 구역들을  체크 

![육각과십이각에있는직각삼각형구하기](육각과십이각에있는직각삼각형구하기.png)


x/y 가 붙어있으면 y분의 x  
x / y 이면 나누기

x = 3^/4

y =  1/2 - 3^/4

y = (2 - 3^)/4


x² = (1/4)²  * ((2 - 3^)/4)²

수학을 할려는거지 산수를 하려는게 아니니까 여기까지 나머지는 계산기로

x = ((1/4)²  * ((2 - 3^)/4)²)^ 
  = 0.2588.... * 12 
  = 3.1058....

이렇게 하면서 계속 늘려나가고 이걸 무한히 깍아버리면 원형이 되버린다.
하지만 완벽한 원형을 만들수가 없다.
무리수니까

왠만해선
박스2D 소프트웨어 내는 10~12자리까지만 보고
우주항공에서도 15자리까지만 써서 생각보다 작게 사용함

우리가 알아야될것은 PI가 정확히 몇이다를 알아야되는게 아니고 
파이가 어떤것이고 어떤식으로 이루어져있는지 우리한테 어떤의미를 있는건지 알아야되는것이 중요하다.


### 6) 라디안(Radian) 대체 이게 뭥미?

세타 미지수
세타는 일생활해서 쓰지는않고 라디안에서 쓰는것이라서 라디안에 대해서 이야기할려고한다.

Degree, 60분법

수학을 다룰때는 
호도법
Radian

호도법 이라는건 

호의 길이로서 특정 각도를 표현하는게 호도 법이다.

정의하기로는

반지름의 길이가 1이고 호의 길이도 1이면 1라디안이라고 정의한다.
사용하는 단위로는 세타를 사용.

PI = 원주/지름 = (원주 / 2)/(지름 / 2);
PI = 반원주/반지름

(똑같이 자른다고 결과값이 달라지지않음)

반지름을 1로 두면 반원주는 PI가 된다

PI = 반원주 / 1
고로 PI는 반원주. 반원주는 180도

이걸 그림으로 표현해보면
![반원](반원.png)

라디안에서 PI를 이야기하는것은 180도  

180도 = PI  
360도 = PI * 2  
90도 =  PI / 2  
45도 = PI / 4  

돌아와서
![1라디안그림](1라디안그림.png)

PI = 180도 이고  
라디안의 정의가 반지름의 길이가 1이고 호(원의 둘레)의 길이도 1 이면 1라디안이니까

※원주(원의둘레) / 2 = 반원주

PI = 반원주/반지름(1) = 180
1라디안 = 180/PI = 57.2958
1 = PI/180 = 0.0175라디안

라디안은 각도다

유니티에서 Mathf.Rad2Deg와 Math.Deg2Rad

이런걸 구지 설명하는 이유는 알고 쓰는거랑 모르고 쓰는거랑 상당한 차이가 있으니까



### 7) 사인과 코사인 (Sin&Cos) part.1 삼각함수의 정확한 의미!?


보통 삼각함수를 이야기하면 Sin Cos Tan를 이야기하는데
오늘은 Sin과 Cos만 이야기할거고  
Sin과 Cos만 가지고 여러패턴들을 만들수 있다.


![삼각함수](삼각함수.png)

Sin이 정확히 어떤의미를 가지고 있는지
삼각함수를 이야기할때 삼각형이 아닌 원이 나온다
삼각형과 원은 땔수가 없는 친구들임

반지름이 1인 원을 단위원 이라고함.


![Sin](Sin.png)

단위원에서 Sin은  
타겟팅 잡은 점정을 기준을 반대편을 길이를 Sin이라고 함  

만약 반지름이 1을 넘어섯으면  
Sin = o/h
Sin = 빗변/높이

글로쓸때는 Sin Cos 인데  
읽을때논 싸인 코싸인  
고로 코싸인은 코 싸인 인건데
상호보완적인 싸인이다.
Co 접두어는 함께 뭔가를 하는 무언가를 이야기함  

고로 Sin을 보완해주는게 Cos 이다.


이걸 그래프로 나타내면

![싸인코싸인그래프](싸인코싸인그래프.png)

0~1로 움직이고
Sin을 Y축으로 하고
Cos을 X축으로 하면은 이렇게 원이 그려짐


![Sin Cos그래프원공식](SinCos그래프원공식.png)

3Cos(t) = 3 * Cos(t)
3 = 원의 반지름
t = 0 ~ 2PI = 0 ~ 360

2Cos(3t) = 2 * Cos(3 * t)

2 = 원의 반지름
3 = 돌아가는 스피드
t = 0 ~ 2PI = 0 ~ 360


### 8)사인과 코사인 (Sin&Cos) part.2 유니티 코드 구현

세타는 0, 360, 720 같은 각도라 무한히 늘어나는거 집어넣어도 됨
![사인코사인코드](사인코사인코드.png)


변경완료
![싸인코싸인커스텀코드](싸인코싸인커스텀코드.png)

### 9)사인과 코사인 (Sin&Cos) part.3

이강의는 사인 코사인이 실제로 어디에 쓰이는지 예를 들어보는 시간.
전 강의에서는 시각적으로 어떤건지 보여주기 위한 시간이여서
실제로 게임이 사인코사인이 어덯게 활용되는지 보고싶다는분이 계셔서
간단한걸로 예를 들겁니다.

빗변 / 높이 = sin
빗변 / 밑변 = cos 

![그림기억하기1](그림기억하기1.png)


벡터의 길이가 1이다.
즉 노말라이즈가 됫다했을떄
이 벡터의 x,y좌표는 어덯게 될까

x = cos(theta)  
y = sin(theta)

![사인코사인3좌](사인코사인3좌.png)



-게임에 적용한 코드

![총알발사스크립트사진](총알발사스크립트사진.png)

gap = 총알 하나하나의 각도  
angle = 총알이 갈라지는 최대 각도범위  
count - 1 = 총알간의 각도. (총알이 4방향으로 나가면 각도는 3부분만 필요하기떄문에 -1)
startAngle = 계산할 기준 각도
-angle / 2 를 한이유는 4사분면 음수로 표현해야됨. 최대 앵글을 반으로 나누고 거기서 음수화시킨 각도가 기준각

float theta = startAngle + gap * i;//여기는 각도로만 표현
theta *= mathf.deg2rad//여기는 각도를 라디안으로 변환

![총알발사사진](총알발사사진.png)
![총알발사사진2](총알발사사진2.png)


#### 20230215

### 10)탄젠트(tangent)


탄젠트의 정의는 sin/cos
 ![탄젠트정의](탄젠트정의.png)

tangent(theta) = sin(theta) / cos(theta)
tangent(theta) = 기울기 = y / x = sin(theta) / cos(theta)


tangent는 **기울기** 라는 컨셉만 기억하면 된다.


![탄젠트는기울기](탄젠트는기울기.png)

기울기를 표현할때 탄젠트가 아니라 엄밀히말하면 역삼각함수가 필요하다

theta = arcsin y
theta = arccos y
theta = arctan y

역삼각함수는
tangent(theta) = y 다 이랬을때 이 역함수는 그 반대로 만들어버림.
y가 sin
인풋과 아웃풋이 있었을때 그 인풋과 아웃풋을 바꿔버림

아크탄젠트 * y = 각도

라디안값으로 반환됨 = mathf.Atan(dir.y, dir.x);


### 11)벡터의 내적 (dot product) part.1 feat. 코사인법칙

벡터의 뺄셈과 덧셈을 다루었으니 이제 곱셈을 다룰차례인데
벡터의 곱셈은 두가지 컨셉이 있다. 하나는 **내적**이고 하나는 **외적**
그중에 내적에 대해서 말할려고함

벡터의 내적은 벡터의 곱셈이다. 그래서 점으로 표시한다.
점으로 표시하기때문에 Dot Product 라고 부르고
곱셈을 할때 a점 b점 이라고 쓰는데 이걸 줄여서 ab라고 줄여서 쓰고
근데 벡터의 내적 점은 생략할수가 없다
a * b == 벡터a * 벡터b * Cos(theta) ==
vector a, b;
(a.x * b.x) + (a.y * b.y) + (a.z * b.z)  (3차원)
(a.x * b.x) + (a.y * b.y)  (2차원)

각각 성분의 곱하고 더한게 내적이 된다.

![벡터의내적](벡터의내적.png)


벡터의 내적은 벡터간의 투영된 길이도 나타내는 의미도 가짐.
벡터의 내적은 두벡터간의 각도를 얻어올수 있는 방법이 된다.

벡터간의 각도는 여러모로 활용되는데
예를 들어 액션게임에서 캐릭터가 몬스터를 때렸다하면 같은방향을 보냐 반대방향을 보냐
판단하는 척도를 세울수 있고

세이더에서는 조명공식에서 기본으로 사용됨.

제 1코사인법칙
![제1코사인법칙](제1코사인법칙.png)

![제1코사인법칙계산법](제1코사인법칙계산법.png)


제 2코사인법칙
a² = b² + c² - 2bc cos(A) 


복잡해보이지만 코사인1법칙을 확장한것
![코사인12법칙](코사인12법칙.png)


최종으로
(대문자 == 점정, 소문자 == 선분)
1법칙 
a = bcos(C) + ccos(B)
b = ccos(A) + acos(C)
c = bcos(A) + acos(B)

2법칙
a² = b² + c² -2bc cos(A)
b² = c² + a² -2ca cos(B)
c² = a² + b² -2ab cos(C)


### 12)벡터의 내적 (dot product) part.2
중고딩때 수학을 완전 포기했던 수포자였슴다. 수학은 항상찍었다.
게임개발을 시작하면서 인터넷을 뒤지고 책보면서 공부했다
수학을 안했던걸 생각해보니까. 학교에서는 수학을 암기과목으로 가르친다.
공식알려주고 왜 그러는지 안알려줌.
그래서 이 비디오 시리즈를 진행하면서 진도, 템포가 떨어져도 최대한 이해하기 쉽게
개념을 설명할려고 한다.

벡터의 내적 공식이 어덯게 나오는지 설명할려고함
vector a, b;
a * b cos(theta)  => 세이더에서 이걸 주로 씀  
a.x * b.x + a.y * b.y + a.z * b.z => 함수 오버헤드가 있어서 이걸 주로씀  

---
벡터의 내적은 벡터의 곱셈 이고.
벡터의 덧셈과 뺄셈은 벡터가 나오지만
벡터의 곱셈은 스칼라가 나오는 버전이 있기도하고 벡터가 나오는 버전이 있다.
`그래서 벡터의 내적은 벡터의 곱셈인데 스칼라로 나오는 버전이다.`
(스칼라는 scale에서 파생된 단어)

기본 개념은 여기서 출발한다.
a * a = a²; 마찬가지로 a↑ * a↑ = a↑²;

![내적공통체크1](내적공통체크1.png)
![내적공통체크2](내적공통체크2.png)

---

### 내적의 증명/유도 1번
a * b  = a↑ * b↑ * cos(theta)
벡터a 와 b 의 내적 == a의길이 * b의길이 * cos(theta)

---
이런 특성을 벡터 a, b 의 길이가 1인 상태 (노말라이즈(0~1)된상태)
이렇게 되면 그냥 cos(theta)가 됨.

1. 두벡터가 같은방향을 바라보고 있는것
theta = 0도 => 벡터a,b = 1

2. 두벡터가 90도. 수직을 이루고 있으면
theta = 90도 => 벡터a,b = 0

3. 두벡터가 서로 반대방향을 보고 있으면
theta = 180도 => 벡터a,b = -1

이라는 결과로 나옴

---


### 내적의 증명/유도 2번
파티고라스의 법칙을 체크
![내적피타고라스유도](내적피타고라스유도.png)

a * a = ax * ax + ay * ay;

a중에 하나를 b로 바꾸면
a * b = ax * bx + ay * by;

이렇게 하면 내적의 공식이 나옴
 
---


### 13)벡터의 내적 (dot product) 응용 1. 벡터의 곱셈


같은방향인지 다른방향인 내적을 통해서 알수가 있다

1이면 같은 방향 0이면 수직 -1이면 반대반향 이라는 특성을 사용함

총알을 진행방향을 노말라이즈, 현재오브젝트의 방향 을 내적해서
0보다 높으면 전방을 보이니까 맞았다고 체크

게임오브젝트에서 총알을 감지할떄 
OnTriggerEnter2D  
{  
    `if( Vector.Dot(총알을 진행방향을 노말라이즈, 현재오브젝트의 방향) > 0);`  
}

![내적정면후면체크정리](내적정면후면체크정리.png)

앞면뒷면을 찾을떄 딱좋아보임

## ※지금까지 소감. 오..늘고 있는게 확실히 느껴짐
이제부터는 그래픽쪽도 같이 봐야할듯

#### 20230216

### 14)셰이더 라이팅의 기본! 벡터의 내적 (dot product) 응용

벡터의 또 다른 응용에 대해서 이야기 해보는 강의


![코사인세타를이용하는](코사인세타를이용하는.png)


cos(theta)가 라이팅처리에서 사용됨.  
내적을 개념은 게임을 포함한 그래픽스랜더링에서 특히 라이팅처리에서 핵심적인 역할을 함  

빛의 량을 1이라고 가정하고 크기도 1이라고 가정하면

수직 = 1
45도일시 = 길이가 어느정도로 길어지는지 체크


![라이팅45도계산](라이팅45도계산.png)

비율이 같으니까

x : 1 = 1 : cos(theta)
x / 1 = 1 / cos(theta)
x = 1 / cos(theta)


노란 삼각형안에 파란삼각형을 그린후 
이 파란삼각형의 빗변의 길이가 1이고
밑변의 길이는 cos(theta)

※ 또나옴 외우자  
sin = y = 높이 = height  
cos = x = 밑변 = width  

![동일한이유](동일한이유.png)



1 / cos(45) = 약1.4  
cos(theta) 사용

![45도시길이](45도시길이.png)


에너지 보존의 법칙
접촉이 없을때 고립계에서 `에너지의 총합은 일정하다.`

일정한 량의 빛이 들어왔을때 빛이라는 에너지를 받는 면적이 좁으면 밝아지고
넓어지면 어두워지는거

※ 빛이 닿는 면적 = 1 / cos(theta)

빛이 닿는 면적의 밝기
= 1 / 빛이 닿는 면적
= 1 / (1 / cos(theta))
= cos(theta)

결국은 빛이라는 면적에 대한 밝기는 Cos(theta).


그래서 그래픽스에서 라이트연산에서 내적을 사용

빛을 봐라보는 벡터 = Light벡터  
면의 방향에 대한 노말벡터  
를 내적한 값을 라이팅결과로 사용  

![라이팅연산에내적사용](라이팅연산에내적사용.png)


빛을 완전히 봐라보는 방향은 1이 나오고  
45도는 약 0.7로 밝기로나옴  
0.5가 아닌 Cos값인 0.7로 나옴  



![내적에대한빛량](내적에대한빛량.png)


이러한 내적을 쉐이더에서 직접사용가능



벡터의 내적을 다루고 나서는 벡터의 외적으로 넘어가야되는데
벡터의 외적을 제대로 이해할려면 행렬을 다루어야됨.






#### 20230218

### 15)행렬 (Matrix) 소개와 곱셈. 매트릭스 알면 핵아재!

행렬, 매트릭스

행과 열로 이루어진 숫자의 조합, 집합

행(Row, 세로)
열(Columns, 가로)

헷깔리면
엔터키 => 개행을 생각하면된다. 그래서 행 다음줄

a1,1 => a의 1행 1열
a1,2 => a의 1행 2열

a3,3 => a의 3행 3열

간략화하면 a3, 3 a3, 2

어찌됫든 표현을 행과 열을 표현한다보면됨


행렬은 트랜스폼으로 표현될수 있다.  

우리 눈에는 포지션과 로테이션값, 스케일값따로 되있지만

내부적으로는 한묶음으로 해서 행렬적로 표현한다.
유니티뿐만 아니라 다른엔진들도 이런식으로 표현한다.

내부구조는 행렬로 사용됨
그래서 행렬이 어덯게 이루어지고 어덯게 다루어 지는지 이야기할려함


트랜스폼이 행렬로 어덯게 표현되는지

이동할때 회전할때 스케일이 변경됫을때 반영해야되는데
이런게 어덯게 반영되는지 확인

행렬의 곱셈은 얼핏봣을때 복잡해보일수 있지만
![행렬의곱셉1](행렬의곱셉1.png)

사실은 내적(벡터의곱셈)으로 이루어져있다.
vector2(a11, a12) * vector2(b11, b21)

앞 매트릭스는 행끼리 벡터로 취급.
뒷 매트릭스는 열끼리 벡터로 취급.


앞  뒤
a→  c↓ d↓
b→ 

a b c d 는 벡터

a * c  a * d  (위에꺼는 a를 곱한거)
b * c  b * d  (아래꺼는 b를 곱한거)

[a11 a12] [b11 b12]
[a21 a22] [b21 b22]

(a11 * b11 + a12 * b21) (a11 * b12 + a12 * b22)
(a21 * b11 + a22 * b21) (a21 * b12 + a22 * b22)

※기억하기(매트릭스의 곱셈)
계산할때 개행을 생각하자.
첫번쨰 개행먼저 식을 다 쓰고 그다음개행을 써가는
방식으로 쓰는 방식을 사용하자

순서가 
개행0을 기준점으로 잡고 열순서대로 내적을 먼저처리
그다음 개행을 기준점으로 위와 똑같이 수행.

![행렬의곱셉2](행렬의곱셉2.png)

[3 1] [4 0]
[0 2] [1 2]

(3 * 4 + 1 * 1) (3 * 0 + 1 * 2)
(0 * 4 + 2 * 1) (0 * 0 + 2 * 2)

[13, 2]
[2, 4]

2by2 행렬 
행by렬


[5 3] [6 7]
[1 4] [9 8]

(5* 6 + 3* 9) (5 * 7 + 3 * 8)

(행렬곱셈 패턴? 보인다는데)
행렬의 열과 렬의 갯수가 서로곱할때 중요하고 이게 트랜스폼다룰때 중요하다

※행렬관련 궁금해서 찾아본구역
1. 덧셈 뺄셈을 하기 위해선 두행렬의 행 과 열이 서로 같아야된다
)가능
2by3은 2by3 
3by3은 3by3 

)불가능
3by2 2by3
3by3 2by2

정리 : AbyB (+-연산) AbyB == 형태여야지 계산이 가능

2. 곱셈은 앞의 렬과 뒷의 행의수가 같아야 곱셈이 가능
)가능
3by2 2by3
2by1 1by2

정리 : AbyB (**연산) BbyA == 형태여야지 계산이 가능

스칼라(어원이 스케일)
행렬의크기와 상관없이 모든원소에 일정한 상수를 곱하는것
[3,2]  2배면  [6,4]
[4,2]         [8,4]


### 16)행렬과 회전,이동,스케일

행렬의 곱이 어덯게 트랜스폼하고 연관되있는지 자세히 알아보도록함.
행렬간의 곱은 내적의 조합으로 이야기할수 있고, 내적의 조합으로 취급할려면

행렬의 행이 하나의 벡터, 열이 하나의 벡터로 취급할수 있다
이런것과 마찬가지 컨셉으로 

-=스케일  
벡터를 하나의 행렬로 취급해서 보여줄수 있다.  
1by2 2by2 는 곱할수 있음  

(Y축으로 * 2)  
[2,1][1,0]  
     [0,2]  

[2 * 1 + 1 * 0][2 * 0 + 1 * 2] = [2,2]  

-=회전  
(90도로 회전)  
[2,1][0,1]  
     [-1,0]  

[2*0+1*-1][2*1+1*0] = [-1,2]  
※아니 이런좋은게 있어? 이러니까 필요하는건구만

![매트릭스의스케일회전](매트릭스의스케일회전.png)

-=회전+이동
행으로 되있는 벡터는 행벡터[1,2]
렬로 표시되있는 벡터는 렬벡터[1]
                           [2] 
[2,1][0,1] + [2,-3]
     [-1,0]
[2 * 0 + 1 * -1][2 * 1 + 1 * 0]
[-1,2] + [2, -3]
[1, -1]

![매트릭스회전이동1](매트릭스회전이동1.png)


이러한 회전과 이동을 한번에 처리해줄수 있음

[2,1,1] [0,1,0]
        [-1,0,0]
        [2,-3,1]
[2 * 0 + 1 * -1 + 1 * 2][2 * 1 + 1 * 0 + 1 * -3][2 * 0 + 1 * 0 + 1 * 1] <=이부분을 곧장계산해서  
[0 + -1 + 2][2 + 0 + -3][0 + 0 + 1]<=이렇게 만들어버리자  
[1, -1, 1]

x,y,z(2차원벡터에 한개더 붙여서 3차원을 만들고 새로만든 곳에 1을 붙여준다)
[2,1] => [2,1,1] 붙여둔 1은 +스케일

그러면 1by3 3by3이 되서 계산할수가 있게됨.

3by3에서 
1by1 ~ 2by2부분이 회전부분
3by1 ~ 3by2부분이 이동부분

1. 회전 2. 이동 
![매트릭스회전이동2](매트릭스회전이동2.png)


### 17)행렬과 트랜스폼

여기서는 행렬 이동, 회전, 스케일이 유니티에서 어덯게 이루어지는 면밀히 살펴본다.

유니티엔진은 3D엔진이라서 z까지 있어서 3차원으로 취급하고 처리됨

그렇기떄문에 3차원 벡터를 다루어야되고
매트릭스는 4by4 4차원벡터로 다루어져야됨.

벡터를 행렬처럼 취급하면서  
열벡터가 있고 행벡터가 있다고 했는데  
마찬가지로 매트릭스행렬도 행기준, 렬기준이 있고  

지금까지보여준건 행기준벡터로 이루어진 행기준 매트릭스였는데  
유니티는 열기준매트릭스 열기준벡터를 다루게 된다.


 x y z Pos  
[0,0,0,0]  
[0,0,0,0]  
[0,0,0,0]  
[0,0,0,0]  

첫번째열은 X  
두번째열은 Y  
세번째열은 Z  
네번째열은 position  
x축의 방향, y축의 방향이 행렬이 기록되있다고 보면 된다.

90도를 돌렸을떄
x축 y축
[0  1 2]
[-1 0 3]
[0  0 1]


![유니티의매트릭스](유니티의매트릭스.png)


3차원벡터를 취급하고 다루기 위해서는 4by4행렬이 필요함

x축의 방향 y축의 방향 z축의 방향 위치  
[0        1          0    2     ]  
[-1       0          0    3     ]  
[0        0          1    0     ]  
[0        0          0    1     ]  

※중요시 볼게 축의방향, 노말라이즈(0~1)사이에서 왔다갔다거림
z회전할시 1by1, 1by2, 2by1, 2by2 쪽에 있는 구역들이 
x회전할시 2by2, 2by3, 3by2, 3by3
y회전할시 1by1, 1by3, 3by1, 3by3

스케일을 변경하면  
x => 1by1부분  
y => 2by2부분  
z => 3by3부분  
여기값에 곱하기 

위치를 변경하면
Pos
[x] => x방향
[y] => y방향
[z] => z방향
[1]

![유니티의매트릭스2](유니티의매트릭스2.png)

### 18)행렬(matrix)의 기준. 열(column)vs 행(row)

행기준 매트릭스
열기준 매트릭스
![행렬매트릭스](행렬매트릭스.png)

행기준 열기준 선택적인거고 3D엔진에서는 반드시 정해준 룰은 없다  
다이렉트x는 행기준이 기본값 
OpenGL은 열기준이 기본값인데  
고정사항이 아니라 선택사항이고  
OpenGL, 유니티는 열기준이니까 열기준으로 설명을 함  

※중요
벡터(v) * 행렬(m) != 행렬(m) * 벡터(v)  
같지 않고 교환법칙이 섭립이 안되서 곱하는순서가 중요함.  

열기준 행렬은 벡터하고 매트릭스를 곱할떄 이런식으로 표현됨
![벡터매트릭스곱](벡터매트릭스곱.png)

※행기준 매트릭스 벡터 곱셈
벡터가 앞, 매트릭스 뒤
vector * matrix = result

※열기준 매트릭스 벡터 곱셈(유니티는 이거 사용함.)
매트릭스가 앞, 벡터가 뒤
matrix * vector = result

matrix4x4    vector4
x y z pos(Local) 박스에 붙어잇는 독수리
[0 1 0 2]       [2] => x
[-1 0 0 3]      [1] => y
[0 0 1 0]       [0] => z
[0 0 0 1]       [1] => w
            독수리의 월드위치
0 1 0 2     [3]
-2 0 0 3    [1]
0 0 0 0     [0]
0 0 0 1     [1]

곱하는 방법은 같음

4by4 4by1 계산가능
![벡터매트릭스곱2](벡터매트릭스곱2.png)

유니티의 오브젝트들은 종속관계로 계층구조로 이루어짐
부모노드가 회전하면 자식한테도 영향을 미침
이런식으로 3D공간에서, 계층구조공간에서 포지션, 로테이션, 스케일
행렬연산에 의해서 결과가 반영됨.
그래서 3D공간을 다룰때 이런행렬에 대해서 알고 있으면 트랜스폼에 대해  
완벽히 이해하고 다룰 수 있게되는것이다


### 19)삼각함수 덧셈정리 : 코사인편

회전행렬에 대해서 다루어봄.  
행렬가지고 이동, 스케일, 회전다루는걸 이야기했는데  
그중 회전행렬을 좀더 자세히볼려고함  

삼각함수에 대한 덧셈정리 외우는법
1. 신코픈꽃신 sin(a+b) = sin(a)cos(b) + cos(a)sin(b)
             sin(a-b) = sin(a)cos(b) - cos(a)sin(b)
2. 고구마사소 cos(a+b) = cos(a)cos(b) + sin(a)sin(b)
             cos(a-b) = cos(a)cos(b) - sin(a)sin(b)

갑자기 삼각함수의 덧셈정리를 왜 말하냐 라면
이 회전행렬을 구할때 삼각함수의 덧셈정리가 이용됨.
행렬회전 구하기 이전에 삼각함수덧셈정리를 이해해야 가능하다

P = (cos(a), sin(a))  
각도는 a  

q = (cos(b), sin(b))  
각도는 b  

p와 q사이의 각도를 theta라고 해두고  

![삼각함수덧셈](삼각함수덧셈.png)


-=z축 회전행렬
[cos(theta) -sin(theta) 0]
[sin(theta) cos(theta)  0]
[0          0           1]
내적의 정의에 대해 다시 이야기함

벡터p, q의 내적은
p의 길이 * q의 길이 * cos(theta)
여기서 p,q의 길이를 = 1로 두면
cos(theta)만 남고  

cos(theta) == cos(a-b);  
px * qx + py * qy == cos(a)cos(b) + sin(a)sin(b);  

이렇게 내적의 공식자체가 삼각함수의 덧셈자체가 되는것이다.

cos(a+b) = (cos(a-(-b))) == cos(a)cos(-b)+sin(a)sin(-b)

r = 1이면
-y/r    -y
x/r     x


cos은 x값이라 x값은 동일하다.
cos(-theta) == cos(theta) 라 결과가 똑같다

sin은 y이라 
sin(-theta) == -sin(theta) 는 같은값으로 도출됨.  

![삼각함수의덧셈정리코사인](삼각함수의덧셈정리코사인.png)

다시보면
cos(a+b) == (cos(a-(-b))) 
== cos(a)cos(-b)+sin(a)sin(-b)

코사인x는 동일한 값이 나오니까 -b => b로 만듬
== cos(a)cos(b) + sin(a)sin(-b)

사인-b의 부분이 앞으로 나오면서 변경
== cos(a)cos(b) - sin(a)sin(b)


### 20)삼각함수 덧셈정리 : 사인(sin)편

sin(0) = 0
cos(0) = 1

sin(90) = 1
cos(90) = 0

90도 == PI/2;

sin하고 cos하고는 90, Pi/2 만큼 차이가 남

![사인코사인파](사인코사인파.png)

sin(a+b) == cos(PI/2 - (a+b)) == cos(PI/2-a-b)
=>(PI/2-a)-b) 이렇게 묶어서 계산
=>cos(a-b) = cos(a)cos(b) + sin(a)sin(b) 이공식을 대입
그러면 밑에 공식으로 변함

== cos(PI/2-a)cos(b) + sin(PI/2-a)sin(b)
=>여기서 PI/2 - a == sin(a), PI/2-a == cos(a)

sin(a+b) = sin(a)cos(b) + cos(a)sin(b)
sin(a-b) == sin(a-(-b))
== sin(a)cos(-b) + cos(a)sin(-b)
=>cos(-theta) == cos(theta)랑 같으니 이걸적용하면

sin(a)cos(b) - cos(a)sin(b) 가 나옴

그래서 삼각함수의 덧셈정리를 증명함
※공식 4개다 해야지 증명이 되는것.


####20230219
### 21)회전 행렬















































































































